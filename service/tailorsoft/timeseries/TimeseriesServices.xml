<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-2.1.xsd">
    <!--   process data point  -->
    <service verb="process" noun="JobRunResults" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="jobName" required="true"/>
            <parameter name="endTime" required="true"/>
            <parameter name="jobName" required="true"/>
            <parameter name="results" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="tailorsoft.timeseries.Monitor" value-field="monitor" cache="true">
                <field-map field-name="jobName"/>
            </entity-find-one>
            <if condition="!monitor">
                <!-- No monitor found, abort -->
                <return/>
            </if>
            <set field="jsonResults" from="new groovy.json.JsonSlurper().parseText(results)"/>

            <!-- TODO, switch to JsonPath: https://github.com/json-path/JsonPath -->
            <set field="pathParts" from="monitor.valuePath.split('\\.')"/>
            <iterate list="pathParts" entry="part">
                <if condition="!jsonResults[part].toString()">
                    <return error="true"
                            message="No value found in ${results} at ${monitor.valuePath} value ${jsonResults[part]}"/>
                </if>
                <set field="jsonResults" from="jsonResults[part]"/>
            </iterate>

            <set field="doubleValue" from="Float.parseFloat(jsonResults.toString())"/>
            <if condition="doubleValue == null">
                <return error="true" message="No double value found at path: ${monitor.valuePath} in ${results} "/>
            </if>

            <!-- store in elasticsearch -->
            <service-call name="tailorsoft.timeseries.TimeseriesServices.save#Datapoint"
                          in-map="[date:endTime, value:doubleValue, indexName:monitor.indexName]"/>

            <if condition="monitor.algorithmEnumId == 'ALGO_BOUNDS'">
                <service-call
                        name="tailorsoft.timeseries.TimeseriesServices.process#DatapointBounds"
                        in-map="[indexName:monitor.indexName, value:doubleValue, date:endDate, jobName:jobName, jobRunId: jobRunId, monitorId: monitor.monitorId, ]"/>
            </if>
        </actions>
    </service>

    <!-- Save date point in elasticsearh   -->
    <service verb="save" noun="Datapoint" authenticate="anonymous-view">
        <in-parameters>
            <parameter name="indexName" required="true"/>
            <parameter name="date" required="true"/>
            <parameter name="value" required="true"/>
        </in-parameters>
        <actions>
            <set field="json" from="[:]"/>
            <script>
                <![CDATA[
                import org.elasticsearch.action.get.MultiGetItemResponse
                import org.elasticsearch.action.get.MultiGetRequestBuilder
                import org.elasticsearch.action.search.SearchRequest
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.index.query.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient

                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)

                //use the default timestamp value
                // @TODO: Parse date from endTime service
                json.put("@timestamp", new Date())
                // value from the service
                json.put("value", value)

                try {
                    Client client = esClient.getClient();

                    if (!esClient.checkIndexExists(indexName)) {
                        client
                                .admin()
                                .indices()
                                .prepareCreate(indexName)
                                .addMapping("_doc", "@timestamp", "type=date", "value", "type=float")
                                .get()

                        logger.info("\n ====== ElasticSearch index created: ${indexName}")
                    }

                    client.prepareIndex(indexName, "_doc").setSource(json).get()
                } finally {

                }
                ]]>
                    </script>
            <log message="\n ====== ElasticSearch Saved:[ ${indexName}, ${date}, ${value} ]"/>
        </actions>
    </service>

    <!--  search Elasticsearch data  -->
    <service verb="process" noun="DatapointBounds" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="jobName"/>
            <parameter name="monitorId"/>
            <parameter name="jobRunId"/>
            <parameter name="indexName"/>
            <parameter name="value"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <log message="\n ======= bounds ${indexName}, ${value}, ${jobName}, ${context} ${monitorId} "/>
            <set field="messageData" from="[:]"/>
            <entity-find-one entity-name="tailorsoft.timeseries.MonitorBounds" value-field="monitorBounds" cache="true">
                <field-map field-name="monitorId"/>
            </entity-find-one>

            <entity-find entity-name="tailorsoft.timeseries.MonitorAlert" list="alertList" limit="1">
                <econdition field-name="monitorId" from="monitorId"/>
                <order-by field-name="-fromDate"/>
            </entity-find>

            <log message="\n ======= entity bounds: ${monitorBounds}"/>

            <script>
                <![CDATA[
                import org.elasticsearch.action.get.MultiGetItemResponse
                import org.elasticsearch.action.get.MultiGetRequestBuilder
                import org.elasticsearch.action.search.SearchRequest
                import org.elasticsearch.action.search.SearchRequestBuilder
                import org.elasticsearch.index.query.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortBuilder
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient
                import org.elasticsearch.action.search.SearchResponse
                import org.elasticsearch.action.search.SearchType;
                import org.elasticsearch.index.query.QueryBuilders.*;
                import org.elasticsearch.search.sort.SortBuilders
                import org.elasticsearch.search.sort.SortOrder

                import javax.naming.directory.SearchControls

                sleep(1200);
                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)

                try {
                    Client client = esClient.getClient();

                    int alertCount = Integer.parseInt(monitorBounds.count.toString())

                    SearchResponse response = client
                            .prepareSearch((String) indexName)
                            .addSort("@timestamp", SortOrder.DESC)
                            .setSize(alertCount)
                            .get()

                    logger.info("\n ======== ES results")
                    logger.info(response.toString())

                    // hits from elasticsearch
                    SearchHits hits = response.getHits()

                    Float upperBound = Float.parseFloat(monitorBounds.upper.toString())
                    Float lowerBound = Float.parseFloat(monitorBounds.lower.toString())
                    int boundsCount = Integer.parseInt(monitorBounds.count.toString());
                    int size = hits.size();

                    if (size < boundsCount) {
                        // too few points to evaluate
                        return false;
                    }

                    Boolean upperBoundAllValid = true;
                    Boolean lowerBoundAllValid = true;

                    for (int i = 0; i < size; i++) {
                        Map hit = hits[i].getSourceAsMap()
                        Float value = Float.parseFloat(hit.value.toString())

                        if (value < upperBound) {
                            upperBoundAllValid = false;
                        }

                        if (value > lowerBound) {
                            lowerBoundAllValid = false;
                        }
                    }

                    logger.info('===== upper and lower bounds')
                    logger.info(upperBoundAllValid.toString())
                    logger.info(lowerBoundAllValid.toString())

                    if (upperBoundAllValid || lowerBoundAllValid) {
                        if (alertList.size() > 0 && alertList[0].status.toString() == 'open') {
                            logger.info('=== last alert still open')
                            // @todo do nothing
                            return false;
                        }

                        Map hit = hits[0].getSourceAsMap()
                        Float value = Float.parseFloat(hit.value.toString())

                        Map notificationData = [
                                id              : jobRunId,
                                jobName         : jobName,
                                jobRunId        : jobRunId,
                                monitorId       : monitorId,
                                fromDate        : new Date(),
                                value           : value,
                                status          : 'open',
                                lastUpdatedStamp: new Date(),
                                from            : 'cristyan.sv@gmail.com'
                        ]
                        notificationId = ec
                                .makeNotificationMessage()
                                .topic(monitorId)
                                .type("danger")
                                .title("Alert Bounds")
                                .message(notificationData)
                                .userGroupId("ALL_USERS")
                                .send()
                                .getNotificationMessageId()

                        ec.service.sync()
                                .name("create#tailorsoft.timeseries.MonitorAlert")
                                .parameters([
                                        id              : jobRunId,
                                        monitorId       : monitorId,
                                        jobName         : jobName,
                                        jobRunId        : jobRunId,
                                        fromDate        : new Date(),
                                        value           : value,
                                        status          : 'open',
                                        notification    : notificationId,
                                        lastUpdatedStamp: new Date(),
                                ])
                                .call()
                        logger.info('==== notification sent')

                    }

                    if (alertList.size() > 0 && alertList[0].status.toString() == 'open') {
                        currentAlert = alertList[0];

                        Boolean restoreValid = true;

                        for (int i = 0; i < size; i++) {
                            Map hit = hits[i].getSourceAsMap()
                            Float value = Float.parseFloat(hit.value.toString())

                            logger.info("alertId: ${currentAlert.id}- ${i.toString()} - ${value.toString()}")

                            if (value > upperBound || value < lowerBound) {
                                restoreValid = false;
                            }
                        }

                        if (restoreValid) {

                            ec.service.sync()
                                    .name("update#tailorsoft.timeseries.MonitorAlert")
                                    .parameters([id: currentAlert.id, status: 'closed'])
                                    .call()

                            logger.info('===== close alert !')
                        }
                    }
                } finally {
                    // TODO close client?
                }
                ]]>
            </script>
        </actions>
    </service>

    <!-- Get charts info   -->
    <service verb="get" noun="Monitors" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="fromDate"/>
            <parameter name="thruDate"/>
            <parameter name="monitorId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="value"/>
        </out-parameters>
        <actions>
            <set field="res" from="[]"/>
            <!-- TODO restrict by Org -->
            <entity-find entity-name="tailorsoft.timeseries.Monitor" list="monitorList"/>

            <set field="fromDateFormated" from="[]"/>
            <set field="thruDateFormated" from="[]"/>
            <script>
                import java.text.SimpleDateFormat

                dateFormat = new SimpleDateFormat("yyyy-MM-dd")
                fromDateFormated = dateFormat.parse(fromDate)
                thruDateFormated = dateFormat.parse(thruDate)
            </script>

            <entity-find entity-name="tailorsoft.timeseries.MonitorAlert" list="alertsList">
                <econdition field-name="monitorId" value="poll_temperature"/>
                <econdition field-name="fromDate" operator="greater" from="fromDateFormated"/>
                <econdition field-name="fromDate" operator="less" from="thruDateFormated"/>
            </entity-find>


            <log message="============================== ${alertsList} ${fromDate} ${thruDate}"/>

            <script>
                 <![CDATA[
                import org.apache.lucene.util.QueryBuilder
                import org.elasticsearch.index.query.QueryBuilders
                import org.elasticsearch.search.SearchHit
                import org.elasticsearch.search.SearchHits
                import org.elasticsearch.search.sort.SortOrder
                import org.elasticsearch.client.Client
                import org.moqui.context.ExecutionContext
                import org.moqui.elasticsearch.ElasticSearchUtil
                import org.moqui.elasticsearch.EsClient
                import org.elasticsearch.action.search.SearchResponse
                import groovy.json.JsonOutput
                import java.text.SimpleDateFormat;

                //create the ES client
                ExecutionContext ec = context.ec
                EsClient esClient = ec.getTool("ElasticSearch", EsClient.class)
                Client client = esClient.getClient();

                logger.info("=================")
                logger.info(fromDate)
                logger.info(thruDate)

                SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd");


                Date fromDateObject = formatter.parse(fromDate)
                Date thruDateObject = formatter.parse(thruDate)

                // get ES data by index
                static List getIndexData(indexName, client, fromDate, thruDate, esClient) {

                    if (!esClient.checkIndexExists(indexName)) {
                        client
                                .admin()
                                .indices()
                                .prepareCreate(indexName)
                                .addMapping("_doc", "@timestamp", "type=date", "value", "type=float")
                                .get()
                    }


                    List hitsList = []

                    SearchHits hits = client
                            .prepareSearch((String) indexName)
                            .setQuery(QueryBuilders.rangeQuery("@timestamp").from(fromDate).to(thruDate))
                            .addSort("@timestamp", SortOrder.DESC)
                            .setSize(9999)
                            .get()
                            .getHits()

                    for (int x = 0; x < hits.size(); x++) {
                        hitsList.push(hits[x].getSourceAsMap())
                    }

                    return hitsList
                }

                if (monitorId) {
                    Map monitorEntity = ec.entity.find("tailorsoft.timeseries.Monitor").condition("monitorId", monitorId).one()
                    Map monitorBoundsEntity = ec.entity.find("tailorsoft.timeseries.MonitorBounds").condition("monitorId", monitorId).one()
                    String indexName = monitorEntity.indexName

                    hitsList = getIndexData(indexName, client, fromDate, thruDate, esClient)

                    alertsList_xafind = ec.entity.find("tailorsoft.timeseries.MonitorAlert")
                            .condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("monitorId", "equals", monitorId, monitorId, null, false, false, false, "false")).condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("fromDate", "greater", fromDateFormated, null, null, false, false, false, "false")).condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("fromDate", "less", thruDateFormated, null, null, false, false, false, "false"))
                    alertsList = alertsList_xafind.list()

                    res.push([jobName: monitorId, monitorId: monitorId, indexName: indexName, data: hitsList, bounds: monitorBoundsEntity, fromDate: fromDateObject, thruDate: thruDateObject, 'alerts': alertsList])

                } else {
                    for (int i = 0; i < monitorList.size(); i++) {
                        String indexName = monitorList[i].indexName
                        String monitorIdStr = monitorList[i].monitorId

                        Map bounds = ec.entity.find("tailorsoft.timeseries.MonitorBounds").condition("monitorId", monitorIdStr).one()

                        hitsList = getIndexData(indexName, client, fromDate, thruDate, esClient)

                        alertsList_xafind = ec.entity.find("tailorsoft.timeseries.MonitorAlert")
                                .condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("monitorId", "equals", monitorId, monitorIdStr, null, false, false, false, "false")).condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("fromDate", "greater", fromDateFormated, null, null, false, false, false, "false")).condition((org.moqui.entity.EntityCondition) ec.entity.conditionFactory.makeActionConditionDirect("fromDate", "less", thruDateFormated, null, null, false, false, false, "false"))
                        alertsList = alertsList_xafind.list()

                        res.push([jobName: monitorIdStr, monitorId: monitorIdStr, indexName: indexName, data: hitsList, bounds: bounds, fromDate: fromDateObject, thruDate: thruDateObject, 'alerts': alertsList])
                    }
                }

                value = res
                ]]>
            </script>
        </actions>
    </service>

    <!-- process single Datapoint   -->
    <service verb="process" noun="DataPoint" authenticate="anonymous-view">
        <in-parameters>
            <parameter name="monitorId" required="true"/>
            <parameter name="pointValue" required="true"/>
        </in-parameters>
        <actions>
            <log message="==== ${monitorId} ${value}"/>

            <entity-find-one entity-name="tailorsoft.timeseries.Monitor" value-field="monitor" cache="true">
                <field-map field-name="monitorId"/>
            </entity-find-one>
            <if condition="!monitor">
                <log message="no monitor '${monitorId}' found, abort"/>
                <!-- No monitor found, abort -->
                <return/>
            </if>

            <set field="doubleValue" from="Float.parseFloat(pointValue)"/>
            <set field="endDate" from="new Date()"/>

            <!-- store in elasticsearch -->
            <service-call name="tailorsoft.timeseries.TimeseriesServices.save#Datapoint"
                          in-map="[date: endDate, value:doubleValue, indexName:monitor.indexName]"/>

            <if condition="monitor.algorithmEnumId == 'ALGO_BOUNDS'">
                <service-call
                        name="tailorsoft.timeseries.TimeseriesServices.process#DatapointBounds"
                        in-map="[indexName:monitor.indexName, value:doubleValue, date:endDate, monitorId: monitor.monitorId, ]"/>
            </if>

        </actions>
    </service>

    <service verb="get" noun="Alerts" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="monitorId"/>
        </in-parameters>
        <actions>
            <log message="hereeee!!!!"/>
            <entity-find entity-name="tailorsoft.timeseries.MonitorAlert" list="alertList" limit="1">
                <econdition field-name="monitorId" from="monitorId"/>
                <order-by field-name="-fromDate"/>
            </entity-find>
            <log message="==== ${alertList}"/>
        </actions>
    </service>

</services>
